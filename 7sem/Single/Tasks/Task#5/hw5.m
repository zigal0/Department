% Домашнее задание №5. Фильтрация.
%> @file hw5.m
% =========================================================================
%> Подготовка рабочего места
% =========================================================================
    %> Отчистка workspace
    clear all;
    %> Закрытие рисунков
    close all;
    %> Отчистка Command Window
    clc;
% =========================================================================
%> Функция sinc. Пример из лекции.
% =========================================================================
    %> Генерим массив
    x = -10:0.1:10;
    %> Функция sinc
    y = sinc(x);
    % =====================================================================
    %> График импульсной характеристики
    % =====================================================================
    figure 
    plot(x,y)
    title('sinc(x)')
    % =====================================================================
    %> График спектра
    % =====================================================================
    %> Фурье + спектр в дБ
    spector = 10*log10(abs(fft(y)));

    %> Полоса по центру
    spector = [spector(102:201), spector(1:101)];
    %> график с учетом T = 2 (см. свойства sinc)
    figure 
    plot(x / 2, spector)
    title('spector sinc(x)')
% =========================================================================
%> Задача 1: Написать функцию, которая генерирует коэффиценты (импульсную 
%> характеристику)для фильтра корень из приподнятого косинуса.
%> Построить импульсную и частотную характеристику фильтра.
% =========================================================================
    %> Длина фильтра в символах (число боковых лепестков sinc, сумма с двух сторон)
    span = 20;
    %> Число выборок на символ
    nsamp  = 4;
    %> Коэффицент сглаживания (alfa)
    rolloff = 0.2;
    % =====================================================================
    %> @todo прописать функцию
    sqimpuls = sqRCcoeff (span, nsamp, rolloff);
    %> @todo построить импульсную и частотную характеристику фильтра
    % .........
    n = span * nsamp + 1;
    figure 
    t = (1 : n) - (n + 1) / 2;
    plot(t, sqimpuls)
    title('sqcos')
    
    spector_sqimpuls = 10 * log10(abs(fft(sqimpuls)));
    spector_sqimpuls = [spector_sqimpuls((n + 1) / 2 + 1 : end), ....
        spector_sqimpuls(1 : (n + 1) / 2)];
    figure 
    plot(t / span, spector_sqimpuls);
    title('spector sqcos')
% =========================================================================
%> Проверка 1.
%> Сравнение со стандартной функцией
% =========================================================================
txfilter1 = comm.RaisedCosineTransmitFilter('RolloffFactor', rolloff, ...
                                           'FilterSpanInSymbols',span,...
                                           'OutputSamplesPerSymbol', nsamp);
chack1 = coeffs(txfilter1);
if sum(abs(chack1.Numerator-sqimpuls))< 0.001 % различно прописанные функции
                                              % могут различаться по точности
    ans = 'Проверка задачи 1 пройдена успешно'
else 
    err = 'Ошибка в задаче 1. Проверьте коэффиценты'
    ans = sum(abs(chack1.Numerator-sqimpuls))
end
% =========================================================================
%> Задача 2: Написать функцию, которая генерирует коэффиценты (импульсную 
%> характеристику)для фильтра приподнятого косинуса.
%> Построить импульсную и частотную характеристику фильтра.
%> Построить импульсную характеристику для корня, без корня и соответсвующий sinc 
%> на одном графике
% =========================================================================
    %> Длина фильтра в символах (число боковых лепестков sinc, сумма с двух сторон)
    span = 20;
    %> Число выборок на символ
    nsamp  = 4;
    %> Коэффицент сглаживания (alfa)
    rolloff = 0.2;
    % =====================================================================
    %> @todo прописать функцию
    impuls = RCcoeff (span, nsamp, rolloff);
    %> @todo gостроить импульсную и частотную характеристику фильтра
    % ........
    n = span * nsamp + 1;
    figure 
    t = (1 : n) - (n + 1) / 2;
    plot(t, impuls)
    title('cos')
    
    figure
    spector_sqimpuls = 10 * log10(abs(fft(sqimpuls)));
    spector_sqimpuls = [spector_sqimpuls((n + 1) / 2 + 1 : end), ....
        spector_sqimpuls(1 : (n + 1) / 2)];
    plot(t / span, spector_sqimpuls);
    title('spector cos')
    %> Импульсная характеристика для корня, без корня и соответсвующий sinc 
    %> на одном графике
    figure
    sp_sinc = sinc(t / nsamp) / 2;
    for_t = zeros(1, numel(t));
    plot (t, sp_sinc, t, sqimpuls, t, impuls, t , for_t)
    legend('sinc', 'sqcos', 'cos')
    title('All impulse characteristics')
% =========================================================================
%> Проверка 2.
%> Сравнение со стандартной функцией
% =========================================================================
txfilter2 = comm.RaisedCosineTransmitFilter('RolloffFactor', rolloff, ...
                                            'FilterSpanInSymbols',span,...
                                            'OutputSamplesPerSymbol', nsamp,...
                                            'Shape', 'Normal');
chack2 = coeffs(txfilter2);
if sum(abs(chack2.Numerator-impuls))< 0.1 % различно прописанные функции
                                          % могут различаться по точности
    ans = 'Проверка задачи 2 пройдена успешно'
else 
    err = 'Ошибка в задаче 2. Проверьте коэффиценты'
    ans = sum(abs(chack2.Numerator-impuls))
end
% =========================================================================
%> Задание 3. 
%> Напишите функцию фильтрации, которая работает в двух режимах: с
%> увеличением колличества выборок на символ и без (повторная фильтрация)
%> @warning используется функция mapping из 1 задания
% =========================================================================
    UpSempFlag = true(1);
    bits = randi([0 1], 1, 1000); % генерация бит
    sign = mapping (bits, 2);       %QPSK 500 символов 
    filtsign = filtration(sign, sqimpuls, nsamp, UpSempFlag);
    % =====================================================================
    %> Проверка 3.1
    %> Проверяем корректность работы ф-ии с передескретизацией со станднартной функцией.
    % =====================================================================
    chack3 = txfilter1(sign.').';
    if sum(abs(chack3-filtsign))< 0.1 % различно прописанные функции
                                      % могут различаться по точности
        ans = 'Проверка задачи 3.1 пройдена успешно'
    else 
        err = 'Ошибка в задаче 3.1. Проверьте фильтр'
        ans = sum(abs(chack3-filtsign))
    end
    % =====================================================================
    %> Проверка 3.2
    %> Проверяем корректность работы ф-ии без передескретизации со станднартной функцией.
    % =====================================================================
    UpSempFlag = false(1);
    filtsign2 = filtration(filtsign, sqimpuls, nsamp, UpSempFlag);
    rxfilter = comm.RaisedCosineReceiveFilter('RolloffFactor', rolloff, ...
                                              'FilterSpanInSymbols',span,...
                                              'InputSamplesPerSymbol', nsamp,...
                                              'DecimationFactor', 1);
    chack4 = rxfilter(filtsign.').';
    if sum(abs(chack4-filtsign2))< 0.1 % различно прописанные функции
                                      % могут различаться по точности
        ans = 'Проверка задачи 3.2 пройдена успешно'
    else 
        err = 'Ошибка в задаче 3.2. Проверьте фильтр'
        ans = sum(abs(chack4-filtsign2))
    end