% Декодер Витерби
%> @file ConvEcod.m
% =========================================================================
%> @brief Декодер Витеби для светочного кода 1/2
%> @param codBits принятые биты
%> @return Bits декодированные биты
% Первая часть функци написанна для облегчения задачи, вы можете ее менять,
% как вам удобно.
% =========================================================================
function Bits = ConvDcod(codBits)
% Начальное состояние буфера
state = [0, 0];
% Массив кодов переходов (используется для расчета расстояния Хэмминга)
%----------------------------------------------------------------------
% следующий бит    0   |   1
conv_arr =      [0, 0,   1, 1;... % начальное состояние 0 (0 0), конечеое 0 (0 0)| конечеое 2 (1 0)
    1, 0,   0, 1;... % начальное состояние 2 (1 0), конечеое 1 (0 1)| конечеое 3 (1 1)
    1, 1,   0, 0;... % начальное состояние 1 (0 1), конечеое 0 (0 0)| конечеое 2 (1 0)
    0, 1,   1, 0];   % начальное состояние 3 (1 1), конечеое 1 (0 1)| конечеое 3 (1 1)

% Массив разрененных кодов переходов (используется для отбрасывания путей)
%----------------------------------------------------------------------
% Начальное состояние (список состояний из которых можно перейти)
map_arr =       [0, 0,   0, 1;...% конечеое состояние 0 (0 0)
    0, 0,   0, 1;...% конечеое состояние 2 (1 0)
    1, 0,   1, 1;...% конечеое состояние 1 (0 1)
    1, 0,   1, 1];  % конечеое состояние 3 (1 1)
% Инициализируем пути
% 1 шаг
% Пути(история бит)
Ways = [0; 1];
Current = codBits(1:2);
n = state(1)+state(2)*2+1; % считаем старшим второй бит
Hdist = [sum(xor(conv_arr(n,1:2),Current)); sum(xor(conv_arr(n,3:4),Current))];
Hdist_ways = Hdist;
state = [0, 0;...
    1, 0];
% 2 шаг
Current = codBits(3:4);
% Пути (история бит)
Ways = [0, 0;...
    0, 1;...
    1, 0;...
    1, 1];
% далее
for i = 1:size(state, 1)
    n = state(i, 1)+state(i, 2)*2+1;
    Hdist = [sum(xor(conv_arr(n,1:2),Current)); sum(xor(conv_arr(n,3:4),Current))];
    % Расстояние Хэмминга
    Hdist_ways_new((i-1)*2+1:(i-1)*2+2,1) = Hdist_ways(i)+Hdist;
end
% Состояние
state = [0, 0;...
    1, 0;...
    0, 1;...
    1, 1];
Hdist_ways = Hdist_ways_new;
% Теперь путь, состояние и расстояние Хэмминга имеют одинаковое
% колличество строк - так и должно быть дальше.

%> @todo место для вашего кода
for j = 3 : numel(codBits) / 2
    Current = codBits(j * 2 - 1 : j * 2);
    for i = 1 : size(state, 1)
        n = state(i, 1) + state(i, 2) * 2 + 1;
        Hdist = [sum(xor(conv_arr(n, 1 : 2), Current)); ...
            sum(xor(conv_arr(n, 3 : 4), Current))];
        update((i - 1) * 2 + 1 : (i - 1) * 2 + 2, 1) = Hdist + Hdist_ways(i);
    end
    new_ways = zeros(size(Ways));
    for k = 1 : 4
        if update(k) < update(k + 4)
            if k < 3
                new_ways(k, :) = Ways(1, :);
            else
                new_ways(k, :) = Ways(2, :);
            end
            Hdist_ways(k) = update(k);
        else
            if k < 3
                new_ways(k, :) = Ways(3, :);
            else
                new_ways(k, :) = Ways(4, :);
            end
            Hdist_ways(k) = update(k + 4);
        end
    end
    Ways = cat(2, new_ways, [0; 1; 0; 1]);
end
[~, res] = min(Hdist_ways);
Bits = Ways(res, :);
end